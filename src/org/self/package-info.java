/**
 * <h2>Recursive Divide-and-Conquer 递归与分治策略</h2>
 * 
 * <h2>Dynamic 动态规划</h2>
 * 
 * <h2>Greedy 贪心算法</h2>
 * 
 * <h2>Backtracking 回溯法</h2>
 * 问题的所有解都能用一棵解空间树表示
 * <p>
 * 可以用深度优先策略来遍历解空间树，如果求取所有解，需要回溯到父节点
 * 
 * <h2>Branch and Bound Method 分支限界法</h2>
 * 问题的所有解都能用一棵解空间树表示
 * <p>
 * 与回溯法不同的是分支限界法是找出当前解空间的最优解
 * 
 * <h2>Randomized Algorithm 随机化算法</h2>
 * 
 * <h2>NP完全性</h2>
 * <ul>
 * <li><b>P类问题</b></li>
 * P类问题又称 Polynomial-time多项式时间问题
 * 
 * <li><b>NP类问题</b></li>
 * NP类问题又称 NondeterministicPolynomial非确定性多项式<p>
 * 不知道存在不存在一个多项式时间的算法，所以叫非确定性多项式问题。<p>
 * 但是我们可以在多项式时间内验证并得出这个问题的一个正确解
 * <p>
 * 例子：旅行售货员问题(TSP)
 * <p>
 * TSP问题是指在图中找出费用最小的周游路线，对于此问题的判定形式是否存在总费用不超过d的路线<p>
 * 该判定问题在一般情况下可以在多项式时间内解决，<b>这就引出一个猜测NP类问题=P类问题</b>
 * <p>
 * 如果解决这个猜测，那是不是所有的NP问题都能在多项式时间内解决<p>
 * 一元一次方程可以通过二元一次方程的解法来解决一元一次方程，只需给一元一次方程附加y=0就行<p>
 * 这就是约化的概念，他是具有传递性的，A传递到B，B传递到C，如果这个约化过程不断传递下去<p>
 * 我们发现存在一个最大的问题，只要解决这个问题，其余的问题也解决了，这就是NPC的概念
 * 
 * <li><b>NP-complete类问题</b></li>
 * 1，NPC问题是一个NP问题
 * <p>
 * 2，所有的NP问题都可以约化成这个NPC问题
 * 
 * <li><b>NP-hard类问题</b></li>
 * 与NPC问题不同的是，所有的NP问题都能约化得到NP-hard问题，但是它不一定是一个NP问题
 * </ul>
 * 
 */
package org.self;
